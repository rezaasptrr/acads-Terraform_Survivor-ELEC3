# ðŸ—ï¸ Terraform Survivor - Architecture Documentation

## Overview

Terraform Survivor is built with a modern, component-based architecture that separates concerns and makes the codebase maintainable and extensible.

## Architecture Layers

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           User Interface (HTML)          â”‚
â”‚         Component Containers             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Component Layer (JS)             â”‚
â”‚  StatsPanel | StoryLog | ActionPanel    â”‚
â”‚  Inventory | TerraformConfig | Modal    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Game Controller (Game.js)        â”‚
â”‚  - State Management                      â”‚
â”‚  - Game Logic                            â”‚
â”‚  - Component Orchestration               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Configuration (config.js)           â”‚
â”‚  Generated by Terraform                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Component System

### Base Component Class

All UI components extend from `Component.js`:

```javascript
class Component {
    constructor(containerId)  // Links to DOM element
    setState(newState)        // Updates state and re-renders
    render()                  // Must be implemented by subclass
    mount()                   // Initial render
    unmount()                 // Cleanup
}
```

### Component Lifecycle

1. **Construction**: Component is instantiated with container ID
2. **Mount**: Initial render is called
3. **State Updates**: `setState()` triggers re-render
4. **Unmount**: Cleanup when component is removed

### Component Communication

Components communicate through the Game controller:

```
User Action â†’ Component â†’ Game Controller â†’ Update State â†’ All Components
```

Example flow:

1. User clicks "Explore" button in ActionPanel
2. ActionPanel calls `onAction('explore')`
3. Game.handleAction() processes the action
4. Game updates player state
5. Game calls `updateAllComponents()`
6. All components re-render with new state

## Game Controller

The `Game` class is the central orchestrator:

### Responsibilities

- **State Management**: Maintains player stats, inventory, game state
- **Game Loop**: Runs continuous updates (hunger/thirst decay)
- **Action Handling**: Processes player actions
- **Component Management**: Creates and updates all UI components
- **Event Generation**: Creates story log messages

### Key Methods

```javascript
constructor(config); // Initialize game with Terraform config
initComponents(); // Create all UI components
startGameLoop(); // Begin continuous updates
handleAction(actionId); // Process player actions
updateAllComponents(); // Refresh all UI components
```

## Data Flow

### Terraform â†’ Game

```
Terraform Variables
    â†“
terraform apply
    â†“
config.js.tpl â†’ config.js
    â†“
window.GAME_CONFIG
    â†“
Game constructor
    â†“
Game state & behavior
```

### Game State â†’ UI

```
Player Action
    â†“
Game.handleAction()
    â†“
Update game state
    â†“
updateAllComponents()
    â†“
component.setState()
    â†“
component.render()
    â†“
DOM Update
```

## Component Details

### StatsPanel

**Purpose**: Display player vital statistics

**State**:

- health, hunger, thirst, energy (0-100)
- day (current day number)

**Features**:

- Animated progress bars
- Color-coded stats
- Real-time updates

### StoryLog

**Purpose**: Display game events and messages

**State**:

- messages: Array of {text, type, timestamp}
- maxMessages: Limit for message history

**Features**:

- Auto-scroll to latest
- Color-coded message types
- Animated message entry

### ActionPanel

**Purpose**: Interactive action buttons

**State**:

- actions: Array of available actions
- disabledActions: Actions that can't be performed

**Features**:

- Energy cost display
- Hover effects
- Disabled state handling

### Inventory

**Purpose**: Display and manage items

**State**:

- items: Object mapping item names to quantities
- selectedItem: Currently selected item

**Features**:

- Grid layout
- Item icons
- Selection highlighting

### TerraformConfig

**Purpose**: Display live Terraform configuration

**State**:

- config: Full Terraform configuration object
- expanded: Whether panel is expanded

**Features**:

- Collapsible panel
- Environment badges
- Real-time config display

### Modal

**Purpose**: Reusable dialog system

**State**:

- isOpen: Boolean
- title: Modal title
- content: HTML content
- type: Modal type (info, danger, craft)

**Features**:

- Overlay backdrop
- Animated entry/exit
- Click-outside to close

## Styling Architecture

### CSS Variables

All colors, sizes, and effects are defined as CSS variables for easy theming:

```css
:root {
  --primary-bg: #1a1d29;
  --accent-blue: #4a9eff;
  --border-radius: 12px;
  /* ... */
}
```

### Component Styling

Each component has dedicated CSS classes:

- `.stats-panel-content`
- `.story-log-wrapper`
- `.action-panel-content`
- `.inventory-content`
- `.terraform-config-wrapper`
- `.modal-overlay`

### Responsive Design

Three breakpoints:

- Desktop: > 1200px (3-column layout)
- Tablet: 768px - 1200px (stacked layout)
- Mobile: < 768px (single column)

## Terraform Integration

### Configuration Flow

1. Define variables in `variables.tf`
2. Set values in `environments/*.tfvars`
3. Template in `config.js.tpl`
4. Generate `config.js` with `terraform apply`
5. Load in browser as `window.GAME_CONFIG`

### Configuration Structure

```javascript
{
    environment: "development",
    difficulty: "easy",
    startingResources: { wood, stone, food },
    gameSettings: {
        hungerDecayRate,
        thirstDecayRate,
        energyDecayRate,
        resourceMultiplier,
        dangerLevel
    },
    features: {
        craftingEnabled,
        weatherEvents,
        randomEvents
    },
    deploymentInfo: {
        version,
        deployedBy,
        timestamp
    }
}
```

## Extension Points

### Adding New Components

1. Create `js/components/NewComponent.js`
2. Extend `Component` base class
3. Implement `render()` method
4. Add to `Game.initComponents()`
5. Add container div in `index.html`
6. Style in `style.css`

### Adding New Actions

1. Add action definition to `ActionPanel` state
2. Add handler in `Game.handleAction()`
3. Implement action logic method
4. Update components with `updateAllComponents()`

### Adding Terraform Variables

1. Define in `variables.tf`
2. Add to `config.js.tpl`
3. Set in `environments/*.tfvars`
4. Access in game via `this.config.newVariable`

## Best Practices

### Component Design

- Keep components focused on single responsibility
- Use state for dynamic data only
- Avoid direct DOM manipulation outside render()
- Communicate through Game controller

### State Management

- Immutable state updates (spread operator)
- Trigger re-render after state changes
- Keep state minimal and derived data in render()

### Performance

- Debounce rapid state updates
- Use CSS transitions over JS animations
- Minimize DOM queries
- Batch component updates

### Code Organization

- One component per file
- Clear naming conventions
- Document complex logic
- Keep methods small and focused

## Testing Strategy

### Component Testing

```javascript
// Test component in isolation
const component = new StatsPanel("test-container");
component.updateStats({ health: 50 });
// Assert DOM state
```

### Integration Testing

```javascript
// Test game flow
const game = new Game(testConfig);
game.explore();
// Assert state changes
```

### Terraform Testing

```bash
# Validate configuration
terraform validate

# Plan without applying
terraform plan -var-file="environments/dev.tfvars"
```

## Future Enhancements

### Potential Features

- Save/load game state to localStorage
- Achievements system
- Multiplayer with WebSockets
- More crafting recipes
- Boss encounters
- Skill tree system

### Architecture Improvements

- State management library (Redux/MobX)
- Virtual DOM for performance
- TypeScript for type safety
- Unit test coverage
- E2E testing with Playwright

## Conclusion

This architecture provides:

- **Modularity**: Easy to add/modify features
- **Maintainability**: Clear separation of concerns
- **Scalability**: Can grow with new features
- **Testability**: Components can be tested independently
- **Terraform Integration**: Configuration as code

The component-based design makes it simple to understand, extend, and maintain the codebase while demonstrating real-world Terraform usage.
